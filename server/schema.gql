# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type About {
  admin: Admin!
  admin_id: String!
  body: String!
  id: String!
  title: String!
  updatedAt: DateTime!
}

type AboutCountAggregate {
  _all: Int!
  admin_id: Int!
  body: Int!
  id: Int!
  title: Int!
  updatedAt: Int!
}

input AboutCountOrderByAggregateInput {
  admin_id: SortOrder
  body: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input AboutCreateInput {
  admin: AdminCreateNestedOneWithoutAboutInput!
  body: String!
  id: String
  title: String!
  updatedAt: DateTime
}

input AboutCreateManyAdminInput {
  body: String!
  id: String
  title: String!
  updatedAt: DateTime
}

input AboutCreateManyAdminInputEnvelope {
  data: [AboutCreateManyAdminInput!]!
  skipDuplicates: Boolean
}

input AboutCreateManyInput {
  admin_id: String!
  body: String!
  id: String
  title: String!
  updatedAt: DateTime
}

input AboutCreateNestedManyWithoutAdminInput {
  connect: [AboutWhereUniqueInput!]
  connectOrCreate: [AboutCreateOrConnectWithoutAdminInput!]
  create: [AboutCreateWithoutAdminInput!]
  createMany: AboutCreateManyAdminInputEnvelope
}

input AboutCreateOrConnectWithoutAdminInput {
  create: AboutCreateWithoutAdminInput!
  where: AboutWhereUniqueInput!
}

input AboutCreateWithoutAdminInput {
  body: String!
  id: String
  title: String!
  updatedAt: DateTime
}

type AboutGroupBy {
  _count: AboutCountAggregate
  _max: AboutMaxAggregate
  _min: AboutMinAggregate
  admin_id: String!
  body: String!
  id: String!
  title: String!
  updatedAt: DateTime!
}

input AboutListRelationFilter {
  every: AboutWhereInput
  none: AboutWhereInput
  some: AboutWhereInput
}

type AboutMaxAggregate {
  admin_id: String
  body: String
  id: String
  title: String
  updatedAt: DateTime
}

input AboutMaxOrderByAggregateInput {
  admin_id: SortOrder
  body: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

type AboutMinAggregate {
  admin_id: String
  body: String
  id: String
  title: String
  updatedAt: DateTime
}

input AboutMinOrderByAggregateInput {
  admin_id: SortOrder
  body: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input AboutOrderByRelationAggregateInput {
  _count: SortOrder
}

input AboutOrderByWithAggregationInput {
  _count: AboutCountOrderByAggregateInput
  _max: AboutMaxOrderByAggregateInput
  _min: AboutMinOrderByAggregateInput
  admin_id: SortOrder
  body: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

input AboutOrderByWithRelationInput {
  admin: AdminOrderByWithRelationInput
  admin_id: SortOrder
  body: SortOrder
  id: SortOrder
  title: SortOrder
  updatedAt: SortOrder
}

enum AboutScalarFieldEnum {
  admin_id
  body
  id
  title
  updatedAt
}

input AboutScalarWhereInput {
  AND: [AboutScalarWhereInput!]
  NOT: [AboutScalarWhereInput!]
  OR: [AboutScalarWhereInput!]
  admin_id: StringFilter
  body: StringFilter
  id: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input AboutScalarWhereWithAggregatesInput {
  AND: [AboutScalarWhereWithAggregatesInput!]
  NOT: [AboutScalarWhereWithAggregatesInput!]
  OR: [AboutScalarWhereWithAggregatesInput!]
  admin_id: StringWithAggregatesFilter
  body: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input AboutUpdateInput {
  admin: AdminUpdateOneRequiredWithoutAboutInput
  body: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AboutUpdateManyMutationInput {
  body: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AboutUpdateManyWithWhereWithoutAdminInput {
  data: AboutUpdateManyMutationInput!
  where: AboutScalarWhereInput!
}

input AboutUpdateManyWithoutAdminInput {
  connect: [AboutWhereUniqueInput!]
  connectOrCreate: [AboutCreateOrConnectWithoutAdminInput!]
  create: [AboutCreateWithoutAdminInput!]
  createMany: AboutCreateManyAdminInputEnvelope
  delete: [AboutWhereUniqueInput!]
  deleteMany: [AboutScalarWhereInput!]
  disconnect: [AboutWhereUniqueInput!]
  set: [AboutWhereUniqueInput!]
  update: [AboutUpdateWithWhereUniqueWithoutAdminInput!]
  updateMany: [AboutUpdateManyWithWhereWithoutAdminInput!]
  upsert: [AboutUpsertWithWhereUniqueWithoutAdminInput!]
}

input AboutUpdateWithWhereUniqueWithoutAdminInput {
  data: AboutUpdateWithoutAdminInput!
  where: AboutWhereUniqueInput!
}

input AboutUpdateWithoutAdminInput {
  body: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AboutUpsertWithWhereUniqueWithoutAdminInput {
  create: AboutCreateWithoutAdminInput!
  update: AboutUpdateWithoutAdminInput!
  where: AboutWhereUniqueInput!
}

input AboutWhereInput {
  AND: [AboutWhereInput!]
  NOT: [AboutWhereInput!]
  OR: [AboutWhereInput!]
  admin: AdminRelationFilter
  admin_id: StringFilter
  body: StringFilter
  id: StringFilter
  title: StringFilter
  updatedAt: DateTimeFilter
}

input AboutWhereUniqueInput {
  id: String
}

type Admin {
  _count: AdminCount
  about(cursor: AboutWhereUniqueInput, distinct: [AboutScalarFieldEnum!], orderBy: [AboutOrderByWithRelationInput!], skip: Int, take: Int, where: AboutWhereInput): [About!]!
  createdAt: DateTime!
  email: String!
  fname: String!
  id: String!
  lname: String!
  messages(cursor: MessageWhereUniqueInput, distinct: [MessageScalarFieldEnum!], orderBy: [MessageOrderByWithRelationInput!], skip: Int, take: Int, where: MessageWhereInput): [Message!]!
  projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  updatedAt: DateTime!
}

type AdminCount {
  about: Int!
  messages: Int!
  projects: Int!
}

type AdminCountAggregate {
  _all: Int!
  apikey: Int!
  createdAt: Int!
  email: Int!
  fname: Int!
  id: Int!
  lname: Int!
  password: Int!
  updatedAt: Int!
}

input AdminCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  fname: SortOrder
  id: SortOrder
  lname: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input AdminCreateInput {
  about: AboutCreateNestedManyWithoutAdminInput
  createdAt: DateTime
  email: String!
  fname: String!
  id: String
  lname: String!
  messages: MessageCreateNestedManyWithoutAdminInput
  password: String!
  projects: ProjectCreateNestedManyWithoutAdminInput
  updatedAt: DateTime
}

input AdminCreateManyInput {
  createdAt: DateTime
  email: String!
  fname: String!
  id: String
  lname: String!
  password: String!
  updatedAt: DateTime
}

input AdminCreateNestedOneWithoutAboutInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutAboutInput
  create: AdminCreateWithoutAboutInput
}

input AdminCreateNestedOneWithoutMessagesInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutMessagesInput
  create: AdminCreateWithoutMessagesInput
}

input AdminCreateNestedOneWithoutProjectsInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutProjectsInput
  create: AdminCreateWithoutProjectsInput
}

input AdminCreateOrConnectWithoutAboutInput {
  create: AdminCreateWithoutAboutInput!
  where: AdminWhereUniqueInput!
}

input AdminCreateOrConnectWithoutMessagesInput {
  create: AdminCreateWithoutMessagesInput!
  where: AdminWhereUniqueInput!
}

input AdminCreateOrConnectWithoutProjectsInput {
  create: AdminCreateWithoutProjectsInput!
  where: AdminWhereUniqueInput!
}

input AdminCreateWithoutAboutInput {
  createdAt: DateTime
  email: String!
  fname: String!
  id: String
  lname: String!
  messages: MessageCreateNestedManyWithoutAdminInput
  password: String!
  projects: ProjectCreateNestedManyWithoutAdminInput
  updatedAt: DateTime
}

input AdminCreateWithoutMessagesInput {
  about: AboutCreateNestedManyWithoutAdminInput
  createdAt: DateTime
  email: String!
  fname: String!
  id: String
  lname: String!
  password: String!
  projects: ProjectCreateNestedManyWithoutAdminInput
  updatedAt: DateTime
}

input AdminCreateWithoutProjectsInput {
  about: AboutCreateNestedManyWithoutAdminInput
  createdAt: DateTime
  email: String!
  fname: String!
  id: String
  lname: String!
  messages: MessageCreateNestedManyWithoutAdminInput
  password: String!
  updatedAt: DateTime
}

type AdminGroupBy {
  _count: AdminCountAggregate
  _max: AdminMaxAggregate
  _min: AdminMinAggregate
  apikey: String
  createdAt: DateTime!
  email: String!
  fname: String!
  id: String!
  lname: String!
  password: String!
  updatedAt: DateTime!
}

type AdminMaxAggregate {
  apikey: String
  createdAt: DateTime
  email: String
  fname: String
  id: String
  lname: String
  password: String
  updatedAt: DateTime
}

input AdminMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  fname: SortOrder
  id: SortOrder
  lname: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

type AdminMinAggregate {
  apikey: String
  createdAt: DateTime
  email: String
  fname: String
  id: String
  lname: String
  password: String
  updatedAt: DateTime
}

input AdminMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  fname: SortOrder
  id: SortOrder
  lname: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input AdminOrderByWithAggregationInput {
  _count: AdminCountOrderByAggregateInput
  _max: AdminMaxOrderByAggregateInput
  _min: AdminMinOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  fname: SortOrder
  id: SortOrder
  lname: SortOrder
  password: SortOrder
  updatedAt: SortOrder
}

input AdminOrderByWithRelationInput {
  about: AboutOrderByRelationAggregateInput
  createdAt: SortOrder
  email: SortOrder
  fname: SortOrder
  id: SortOrder
  lname: SortOrder
  messages: MessageOrderByRelationAggregateInput
  password: SortOrder
  projects: ProjectOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input AdminRelationFilter {
  is: AdminWhereInput
  isNot: AdminWhereInput
}

enum AdminScalarFieldEnum {
  apikey
  createdAt
  email
  fname
  id
  lname
  password
  updatedAt
}

input AdminScalarWhereWithAggregatesInput {
  AND: [AdminScalarWhereWithAggregatesInput!]
  NOT: [AdminScalarWhereWithAggregatesInput!]
  OR: [AdminScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  fname: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lname: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input AdminUpdateInput {
  about: AboutUpdateManyWithoutAdminInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  fname: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lname: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAdminInput
  password: StringFieldUpdateOperationsInput
  projects: ProjectUpdateManyWithoutAdminInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AdminUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  fname: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lname: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AdminUpdateOneRequiredWithoutAboutInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutAboutInput
  create: AdminCreateWithoutAboutInput
  update: AdminUpdateWithoutAboutInput
  upsert: AdminUpsertWithoutAboutInput
}

input AdminUpdateOneRequiredWithoutMessagesInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutMessagesInput
  create: AdminCreateWithoutMessagesInput
  update: AdminUpdateWithoutMessagesInput
  upsert: AdminUpsertWithoutMessagesInput
}

input AdminUpdateOneRequiredWithoutProjectsInput {
  connect: AdminWhereUniqueInput
  connectOrCreate: AdminCreateOrConnectWithoutProjectsInput
  create: AdminCreateWithoutProjectsInput
  update: AdminUpdateWithoutProjectsInput
  upsert: AdminUpsertWithoutProjectsInput
}

input AdminUpdateWithoutAboutInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  fname: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lname: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAdminInput
  password: StringFieldUpdateOperationsInput
  projects: ProjectUpdateManyWithoutAdminInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AdminUpdateWithoutMessagesInput {
  about: AboutUpdateManyWithoutAdminInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  fname: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lname: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  projects: ProjectUpdateManyWithoutAdminInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AdminUpdateWithoutProjectsInput {
  about: AboutUpdateManyWithoutAdminInput
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  fname: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lname: StringFieldUpdateOperationsInput
  messages: MessageUpdateManyWithoutAdminInput
  password: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input AdminUpsertWithoutAboutInput {
  create: AdminCreateWithoutAboutInput!
  update: AdminUpdateWithoutAboutInput!
}

input AdminUpsertWithoutMessagesInput {
  create: AdminCreateWithoutMessagesInput!
  update: AdminUpdateWithoutMessagesInput!
}

input AdminUpsertWithoutProjectsInput {
  create: AdminCreateWithoutProjectsInput!
  update: AdminUpdateWithoutProjectsInput!
}

input AdminWhereInput {
  AND: [AdminWhereInput!]
  NOT: [AdminWhereInput!]
  OR: [AdminWhereInput!]
  about: AboutListRelationFilter
  createdAt: DateTimeFilter
  email: StringFilter
  fname: StringFilter
  id: StringFilter
  lname: StringFilter
  messages: MessageListRelationFilter
  password: StringFilter
  projects: ProjectListRelationFilter
  updatedAt: DateTimeFilter
}

input AdminWhereUniqueInput {
  email: String
  id: String
}

type AffectedRowsOutput {
  count: Int!
}

type AggregateAbout {
  _count: AboutCountAggregate
  _max: AboutMaxAggregate
  _min: AboutMinAggregate
}

type AggregateAdmin {
  _count: AdminCountAggregate
  _max: AdminMaxAggregate
  _min: AdminMinAggregate
}

type AggregateAnswer {
  _count: AnswerCountAggregate
  _max: AnswerMaxAggregate
  _min: AnswerMinAggregate
}

type AggregateMessage {
  _count: MessageCountAggregate
  _max: MessageMaxAggregate
  _min: MessageMinAggregate
}

type AggregateProject {
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
}

type AggregateQuestion {
  _count: QuestionCountAggregate
  _max: QuestionMaxAggregate
  _min: QuestionMinAggregate
}

type AggregateSketch {
  _count: SketchCountAggregate
  _max: SketchMaxAggregate
  _min: SketchMinAggregate
}

type AggregateTech {
  _count: TechCountAggregate
  _max: TechMaxAggregate
  _min: TechMinAggregate
}

type AggregateTechCategory {
  _count: TechCategoryCountAggregate
  _max: TechCategoryMaxAggregate
  _min: TechCategoryMinAggregate
}

type Answer {
  answer: String!
  id: String!
  question: Question
}

type AnswerCountAggregate {
  _all: Int!
  answer: Int!
  id: Int!
}

input AnswerCountOrderByAggregateInput {
  answer: SortOrder
  id: SortOrder
}

input AnswerCreateInput {
  answer: String!
  id: String
  question: QuestionCreateNestedOneWithoutAnswerInput
}

input AnswerCreateManyInput {
  answer: String!
  id: String
}

input AnswerCreateNestedOneWithoutQuestionInput {
  connect: AnswerWhereUniqueInput
  connectOrCreate: AnswerCreateOrConnectWithoutQuestionInput
  create: AnswerCreateWithoutQuestionInput
}

input AnswerCreateOrConnectWithoutQuestionInput {
  create: AnswerCreateWithoutQuestionInput!
  where: AnswerWhereUniqueInput!
}

input AnswerCreateWithoutQuestionInput {
  answer: String!
  id: String
}

type AnswerGroupBy {
  _count: AnswerCountAggregate
  _max: AnswerMaxAggregate
  _min: AnswerMinAggregate
  answer: String!
  id: String!
}

type AnswerMaxAggregate {
  answer: String
  id: String
}

input AnswerMaxOrderByAggregateInput {
  answer: SortOrder
  id: SortOrder
}

type AnswerMinAggregate {
  answer: String
  id: String
}

input AnswerMinOrderByAggregateInput {
  answer: SortOrder
  id: SortOrder
}

input AnswerOrderByWithAggregationInput {
  _count: AnswerCountOrderByAggregateInput
  _max: AnswerMaxOrderByAggregateInput
  _min: AnswerMinOrderByAggregateInput
  answer: SortOrder
  id: SortOrder
}

input AnswerOrderByWithRelationInput {
  answer: SortOrder
  id: SortOrder
  question: QuestionOrderByWithRelationInput
}

input AnswerRelationFilter {
  is: AnswerWhereInput
  isNot: AnswerWhereInput
}

enum AnswerScalarFieldEnum {
  answer
  id
}

input AnswerScalarWhereWithAggregatesInput {
  AND: [AnswerScalarWhereWithAggregatesInput!]
  NOT: [AnswerScalarWhereWithAggregatesInput!]
  OR: [AnswerScalarWhereWithAggregatesInput!]
  answer: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
}

input AnswerUpdateInput {
  answer: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  question: QuestionUpdateOneWithoutAnswerInput
}

input AnswerUpdateManyMutationInput {
  answer: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input AnswerUpdateOneRequiredWithoutQuestionInput {
  connect: AnswerWhereUniqueInput
  connectOrCreate: AnswerCreateOrConnectWithoutQuestionInput
  create: AnswerCreateWithoutQuestionInput
  update: AnswerUpdateWithoutQuestionInput
  upsert: AnswerUpsertWithoutQuestionInput
}

input AnswerUpdateWithoutQuestionInput {
  answer: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
}

input AnswerUpsertWithoutQuestionInput {
  create: AnswerCreateWithoutQuestionInput!
  update: AnswerUpdateWithoutQuestionInput!
}

input AnswerWhereInput {
  AND: [AnswerWhereInput!]
  NOT: [AnswerWhereInput!]
  OR: [AnswerWhereInput!]
  answer: StringFilter
  id: StringFilter
  question: QuestionRelationFilter
}

input AnswerWhereUniqueInput {
  id: String
}

input BoolFieldUpdateOperationsInput {
  set: Boolean
}

input BoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input BoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Message {
  admin: Admin!
  admin_id: String!
  answer_status: Boolean!
  body: String!
  createdAd: DateTime!
  from: String!
  id: String!
  read_status: Boolean!
  subject: String!
}

type MessageCountAggregate {
  _all: Int!
  admin_id: Int!
  answer_status: Int!
  body: Int!
  createdAd: Int!
  from: Int!
  id: Int!
  read_status: Int!
  subject: Int!
}

input MessageCountOrderByAggregateInput {
  admin_id: SortOrder
  answer_status: SortOrder
  body: SortOrder
  createdAd: SortOrder
  from: SortOrder
  id: SortOrder
  read_status: SortOrder
  subject: SortOrder
}

input MessageCreateInput {
  admin: AdminCreateNestedOneWithoutMessagesInput!
  answer_status: Boolean
  body: String!
  createdAd: DateTime
  from: String!
  id: String
  read_status: Boolean
  subject: String!
}

input MessageCreateManyAdminInput {
  answer_status: Boolean
  body: String!
  createdAd: DateTime
  from: String!
  id: String
  read_status: Boolean
  subject: String!
}

input MessageCreateManyAdminInputEnvelope {
  data: [MessageCreateManyAdminInput!]!
  skipDuplicates: Boolean
}

input MessageCreateManyInput {
  admin_id: String!
  answer_status: Boolean
  body: String!
  createdAd: DateTime
  from: String!
  id: String
  read_status: Boolean
  subject: String!
}

input MessageCreateNestedManyWithoutAdminInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutAdminInput!]
  create: [MessageCreateWithoutAdminInput!]
  createMany: MessageCreateManyAdminInputEnvelope
}

input MessageCreateOrConnectWithoutAdminInput {
  create: MessageCreateWithoutAdminInput!
  where: MessageWhereUniqueInput!
}

input MessageCreateWithoutAdminInput {
  answer_status: Boolean
  body: String!
  createdAd: DateTime
  from: String!
  id: String
  read_status: Boolean
  subject: String!
}

type MessageGroupBy {
  _count: MessageCountAggregate
  _max: MessageMaxAggregate
  _min: MessageMinAggregate
  admin_id: String!
  answer_status: Boolean!
  body: String!
  createdAd: DateTime!
  from: String!
  id: String!
  read_status: Boolean!
  subject: String!
}

input MessageListRelationFilter {
  every: MessageWhereInput
  none: MessageWhereInput
  some: MessageWhereInput
}

type MessageMaxAggregate {
  admin_id: String
  answer_status: Boolean
  body: String
  createdAd: DateTime
  from: String
  id: String
  read_status: Boolean
  subject: String
}

input MessageMaxOrderByAggregateInput {
  admin_id: SortOrder
  answer_status: SortOrder
  body: SortOrder
  createdAd: SortOrder
  from: SortOrder
  id: SortOrder
  read_status: SortOrder
  subject: SortOrder
}

type MessageMinAggregate {
  admin_id: String
  answer_status: Boolean
  body: String
  createdAd: DateTime
  from: String
  id: String
  read_status: Boolean
  subject: String
}

input MessageMinOrderByAggregateInput {
  admin_id: SortOrder
  answer_status: SortOrder
  body: SortOrder
  createdAd: SortOrder
  from: SortOrder
  id: SortOrder
  read_status: SortOrder
  subject: SortOrder
}

input MessageOrderByRelationAggregateInput {
  _count: SortOrder
}

input MessageOrderByWithAggregationInput {
  _count: MessageCountOrderByAggregateInput
  _max: MessageMaxOrderByAggregateInput
  _min: MessageMinOrderByAggregateInput
  admin_id: SortOrder
  answer_status: SortOrder
  body: SortOrder
  createdAd: SortOrder
  from: SortOrder
  id: SortOrder
  read_status: SortOrder
  subject: SortOrder
}

input MessageOrderByWithRelationInput {
  admin: AdminOrderByWithRelationInput
  admin_id: SortOrder
  answer_status: SortOrder
  body: SortOrder
  createdAd: SortOrder
  from: SortOrder
  id: SortOrder
  read_status: SortOrder
  subject: SortOrder
}

enum MessageScalarFieldEnum {
  admin_id
  answer_status
  body
  createdAd
  from
  id
  read_status
  subject
}

input MessageScalarWhereInput {
  AND: [MessageScalarWhereInput!]
  NOT: [MessageScalarWhereInput!]
  OR: [MessageScalarWhereInput!]
  admin_id: StringFilter
  answer_status: BoolFilter
  body: StringFilter
  createdAd: DateTimeFilter
  from: StringFilter
  id: StringFilter
  read_status: BoolFilter
  subject: StringFilter
}

input MessageScalarWhereWithAggregatesInput {
  AND: [MessageScalarWhereWithAggregatesInput!]
  NOT: [MessageScalarWhereWithAggregatesInput!]
  OR: [MessageScalarWhereWithAggregatesInput!]
  admin_id: StringWithAggregatesFilter
  answer_status: BoolWithAggregatesFilter
  body: StringWithAggregatesFilter
  createdAd: DateTimeWithAggregatesFilter
  from: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  read_status: BoolWithAggregatesFilter
  subject: StringWithAggregatesFilter
}

input MessageUpdateInput {
  admin: AdminUpdateOneRequiredWithoutMessagesInput
  answer_status: BoolFieldUpdateOperationsInput
  body: StringFieldUpdateOperationsInput
  createdAd: DateTimeFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  read_status: BoolFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
}

input MessageUpdateManyMutationInput {
  answer_status: BoolFieldUpdateOperationsInput
  body: StringFieldUpdateOperationsInput
  createdAd: DateTimeFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  read_status: BoolFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
}

input MessageUpdateManyWithWhereWithoutAdminInput {
  data: MessageUpdateManyMutationInput!
  where: MessageScalarWhereInput!
}

input MessageUpdateManyWithoutAdminInput {
  connect: [MessageWhereUniqueInput!]
  connectOrCreate: [MessageCreateOrConnectWithoutAdminInput!]
  create: [MessageCreateWithoutAdminInput!]
  createMany: MessageCreateManyAdminInputEnvelope
  delete: [MessageWhereUniqueInput!]
  deleteMany: [MessageScalarWhereInput!]
  disconnect: [MessageWhereUniqueInput!]
  set: [MessageWhereUniqueInput!]
  update: [MessageUpdateWithWhereUniqueWithoutAdminInput!]
  updateMany: [MessageUpdateManyWithWhereWithoutAdminInput!]
  upsert: [MessageUpsertWithWhereUniqueWithoutAdminInput!]
}

input MessageUpdateWithWhereUniqueWithoutAdminInput {
  data: MessageUpdateWithoutAdminInput!
  where: MessageWhereUniqueInput!
}

input MessageUpdateWithoutAdminInput {
  answer_status: BoolFieldUpdateOperationsInput
  body: StringFieldUpdateOperationsInput
  createdAd: DateTimeFieldUpdateOperationsInput
  from: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  read_status: BoolFieldUpdateOperationsInput
  subject: StringFieldUpdateOperationsInput
}

input MessageUpsertWithWhereUniqueWithoutAdminInput {
  create: MessageCreateWithoutAdminInput!
  update: MessageUpdateWithoutAdminInput!
  where: MessageWhereUniqueInput!
}

input MessageWhereInput {
  AND: [MessageWhereInput!]
  NOT: [MessageWhereInput!]
  OR: [MessageWhereInput!]
  admin: AdminRelationFilter
  admin_id: StringFilter
  answer_status: BoolFilter
  body: StringFilter
  createdAd: DateTimeFilter
  from: StringFilter
  id: StringFilter
  read_status: BoolFilter
  subject: StringFilter
}

input MessageWhereUniqueInput {
  id: String
}

type Mutation {
  createAbout(data: AboutCreateInput!): About!
  createAdmin(data: AdminCreateInput!): Admin!
  createAnswer(data: AnswerCreateInput!): Answer!
  createManyAbout(data: [AboutCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyAdmin(data: [AdminCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyAnswer(data: [AnswerCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyMessage(data: [MessageCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProject(data: [ProjectCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyQuestion(data: [QuestionCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySketch(data: [SketchCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTech(data: [TechCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTechCategory(data: [TechCategoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createMessage(data: MessageCreateInput!): Message!
  createProject(data: ProjectCreateInput!): Project!
  createQuestion(data: QuestionCreateInput!): Question!
  createSketch(data: SketchCreateInput!): Sketch!
  createTech(data: TechCreateInput!): Tech!
  createTechCategory(data: TechCategoryCreateInput!): TechCategory!
  deleteAbout(where: AboutWhereUniqueInput!): About
  deleteAdmin(where: AdminWhereUniqueInput!): Admin
  deleteAnswer(where: AnswerWhereUniqueInput!): Answer
  deleteManyAbout(where: AboutWhereInput): AffectedRowsOutput!
  deleteManyAdmin(where: AdminWhereInput): AffectedRowsOutput!
  deleteManyAnswer(where: AnswerWhereInput): AffectedRowsOutput!
  deleteManyMessage(where: MessageWhereInput): AffectedRowsOutput!
  deleteManyProject(where: ProjectWhereInput): AffectedRowsOutput!
  deleteManyQuestion(where: QuestionWhereInput): AffectedRowsOutput!
  deleteManySketch(where: SketchWhereInput): AffectedRowsOutput!
  deleteManyTech(where: TechWhereInput): AffectedRowsOutput!
  deleteManyTechCategory(where: TechCategoryWhereInput): AffectedRowsOutput!
  deleteMessage(where: MessageWhereUniqueInput!): Message
  deleteProject(where: ProjectWhereUniqueInput!): Project
  deleteQuestion(where: QuestionWhereUniqueInput!): Question
  deleteSketch(where: SketchWhereUniqueInput!): Sketch
  deleteTech(where: TechWhereUniqueInput!): Tech
  deleteTechCategory(where: TechCategoryWhereUniqueInput!): TechCategory
  updateAbout(data: AboutUpdateInput!, where: AboutWhereUniqueInput!): About
  updateAdmin(data: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin
  updateAnswer(data: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer
  updateManyAbout(data: AboutUpdateManyMutationInput!, where: AboutWhereInput): AffectedRowsOutput!
  updateManyAdmin(data: AdminUpdateManyMutationInput!, where: AdminWhereInput): AffectedRowsOutput!
  updateManyAnswer(data: AnswerUpdateManyMutationInput!, where: AnswerWhereInput): AffectedRowsOutput!
  updateManyMessage(data: MessageUpdateManyMutationInput!, where: MessageWhereInput): AffectedRowsOutput!
  updateManyProject(data: ProjectUpdateManyMutationInput!, where: ProjectWhereInput): AffectedRowsOutput!
  updateManyQuestion(data: QuestionUpdateManyMutationInput!, where: QuestionWhereInput): AffectedRowsOutput!
  updateManySketch(data: SketchUpdateManyMutationInput!, where: SketchWhereInput): AffectedRowsOutput!
  updateManyTech(data: TechUpdateManyMutationInput!, where: TechWhereInput): AffectedRowsOutput!
  updateManyTechCategory(data: TechCategoryUpdateManyMutationInput!, where: TechCategoryWhereInput): AffectedRowsOutput!
  updateMessage(data: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message
  updateProject(data: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project
  updateQuestion(data: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question
  updateSketch(data: SketchUpdateInput!, where: SketchWhereUniqueInput!): Sketch
  updateTech(data: TechUpdateInput!, where: TechWhereUniqueInput!): Tech
  updateTechCategory(data: TechCategoryUpdateInput!, where: TechCategoryWhereUniqueInput!): TechCategory
  upsertAbout(create: AboutCreateInput!, update: AboutUpdateInput!, where: AboutWhereUniqueInput!): About!
  upsertAdmin(create: AdminCreateInput!, update: AdminUpdateInput!, where: AdminWhereUniqueInput!): Admin!
  upsertAnswer(create: AnswerCreateInput!, update: AnswerUpdateInput!, where: AnswerWhereUniqueInput!): Answer!
  upsertMessage(create: MessageCreateInput!, update: MessageUpdateInput!, where: MessageWhereUniqueInput!): Message!
  upsertProject(create: ProjectCreateInput!, update: ProjectUpdateInput!, where: ProjectWhereUniqueInput!): Project!
  upsertQuestion(create: QuestionCreateInput!, update: QuestionUpdateInput!, where: QuestionWhereUniqueInput!): Question!
  upsertSketch(create: SketchCreateInput!, update: SketchUpdateInput!, where: SketchWhereUniqueInput!): Sketch!
  upsertTech(create: TechCreateInput!, update: TechUpdateInput!, where: TechWhereUniqueInput!): Tech!
  upsertTechCategory(create: TechCategoryCreateInput!, update: TechCategoryUpdateInput!, where: TechCategoryWhereUniqueInput!): TechCategory!
}

input NestedBoolFilter {
  equals: Boolean
  not: NestedBoolFilter
}

input NestedBoolWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedBoolFilter
  _min: NestedBoolFilter
  equals: Boolean
  not: NestedBoolWithAggregatesFilter
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Project {
  _count: ProjectCount
  admin: Admin!
  admin_id: String!
  app_url: String!
  createdAt: DateTime!
  description: String!
  github_url: String!
  id: String!
  image: String!
  name: String!
  questions(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum!], orderBy: [QuestionOrderByWithRelationInput!], skip: Int, take: Int, where: QuestionWhereInput): [Question!]!
  sketches(cursor: SketchWhereUniqueInput, distinct: [SketchScalarFieldEnum!], orderBy: [SketchOrderByWithRelationInput!], skip: Int, take: Int, where: SketchWhereInput): [Sketch!]!
  tech_categories(cursor: TechCategoryWhereUniqueInput, distinct: [TechCategoryScalarFieldEnum!], orderBy: [TechCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: TechCategoryWhereInput): [TechCategory!]!
  updatedAt: DateTime!
}

type ProjectCount {
  questions: Int!
  sketches: Int!
  tech_categories: Int!
}

type ProjectCountAggregate {
  _all: Int!
  admin_id: Int!
  app_url: Int!
  createdAt: Int!
  description: Int!
  github_url: Int!
  id: Int!
  image: Int!
  name: Int!
  updatedAt: Int!
}

input ProjectCountOrderByAggregateInput {
  admin_id: SortOrder
  app_url: SortOrder
  createdAt: SortOrder
  description: SortOrder
  github_url: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ProjectCreateInput {
  admin: AdminCreateNestedOneWithoutProjectsInput!
  app_url: String!
  createdAt: DateTime
  description: String!
  github_url: String!
  id: String
  image: String!
  name: String!
  questions: QuestionCreateNestedManyWithoutProjectInput
  sketches: SketchCreateNestedManyWithoutProjectInput
  tech_categories: TechCategoryCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

input ProjectCreateManyAdminInput {
  app_url: String!
  createdAt: DateTime
  description: String!
  github_url: String!
  id: String
  image: String!
  name: String!
  updatedAt: DateTime
}

input ProjectCreateManyAdminInputEnvelope {
  data: [ProjectCreateManyAdminInput!]!
  skipDuplicates: Boolean
}

input ProjectCreateManyInput {
  admin_id: String!
  app_url: String!
  createdAt: DateTime
  description: String!
  github_url: String!
  id: String
  image: String!
  name: String!
  updatedAt: DateTime
}

input ProjectCreateNestedManyWithoutAdminInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutAdminInput!]
  create: [ProjectCreateWithoutAdminInput!]
  createMany: ProjectCreateManyAdminInputEnvelope
}

input ProjectCreateNestedOneWithoutQuestionsInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutQuestionsInput
  create: ProjectCreateWithoutQuestionsInput
}

input ProjectCreateNestedOneWithoutSketchesInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutSketchesInput
  create: ProjectCreateWithoutSketchesInput
}

input ProjectCreateNestedOneWithoutTech_categoriesInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutTech_categoriesInput
  create: ProjectCreateWithoutTech_categoriesInput
}

input ProjectCreateOrConnectWithoutAdminInput {
  create: ProjectCreateWithoutAdminInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutQuestionsInput {
  create: ProjectCreateWithoutQuestionsInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutSketchesInput {
  create: ProjectCreateWithoutSketchesInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateOrConnectWithoutTech_categoriesInput {
  create: ProjectCreateWithoutTech_categoriesInput!
  where: ProjectWhereUniqueInput!
}

input ProjectCreateWithoutAdminInput {
  app_url: String!
  createdAt: DateTime
  description: String!
  github_url: String!
  id: String
  image: String!
  name: String!
  questions: QuestionCreateNestedManyWithoutProjectInput
  sketches: SketchCreateNestedManyWithoutProjectInput
  tech_categories: TechCategoryCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

input ProjectCreateWithoutQuestionsInput {
  admin: AdminCreateNestedOneWithoutProjectsInput!
  app_url: String!
  createdAt: DateTime
  description: String!
  github_url: String!
  id: String
  image: String!
  name: String!
  sketches: SketchCreateNestedManyWithoutProjectInput
  tech_categories: TechCategoryCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

input ProjectCreateWithoutSketchesInput {
  admin: AdminCreateNestedOneWithoutProjectsInput!
  app_url: String!
  createdAt: DateTime
  description: String!
  github_url: String!
  id: String
  image: String!
  name: String!
  questions: QuestionCreateNestedManyWithoutProjectInput
  tech_categories: TechCategoryCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

input ProjectCreateWithoutTech_categoriesInput {
  admin: AdminCreateNestedOneWithoutProjectsInput!
  app_url: String!
  createdAt: DateTime
  description: String!
  github_url: String!
  id: String
  image: String!
  name: String!
  questions: QuestionCreateNestedManyWithoutProjectInput
  sketches: SketchCreateNestedManyWithoutProjectInput
  updatedAt: DateTime
}

type ProjectGroupBy {
  _count: ProjectCountAggregate
  _max: ProjectMaxAggregate
  _min: ProjectMinAggregate
  admin_id: String!
  app_url: String!
  createdAt: DateTime!
  description: String!
  github_url: String!
  id: String!
  image: String!
  name: String!
  updatedAt: DateTime!
}

input ProjectListRelationFilter {
  every: ProjectWhereInput
  none: ProjectWhereInput
  some: ProjectWhereInput
}

type ProjectMaxAggregate {
  admin_id: String
  app_url: String
  createdAt: DateTime
  description: String
  github_url: String
  id: String
  image: String
  name: String
  updatedAt: DateTime
}

input ProjectMaxOrderByAggregateInput {
  admin_id: SortOrder
  app_url: SortOrder
  createdAt: SortOrder
  description: SortOrder
  github_url: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type ProjectMinAggregate {
  admin_id: String
  app_url: String
  createdAt: DateTime
  description: String
  github_url: String
  id: String
  image: String
  name: String
  updatedAt: DateTime
}

input ProjectMinOrderByAggregateInput {
  admin_id: SortOrder
  app_url: SortOrder
  createdAt: SortOrder
  description: SortOrder
  github_url: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ProjectOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProjectOrderByWithAggregationInput {
  _count: ProjectCountOrderByAggregateInput
  _max: ProjectMaxOrderByAggregateInput
  _min: ProjectMinOrderByAggregateInput
  admin_id: SortOrder
  app_url: SortOrder
  createdAt: SortOrder
  description: SortOrder
  github_url: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input ProjectOrderByWithRelationInput {
  admin: AdminOrderByWithRelationInput
  admin_id: SortOrder
  app_url: SortOrder
  createdAt: SortOrder
  description: SortOrder
  github_url: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  questions: QuestionOrderByRelationAggregateInput
  sketches: SketchOrderByRelationAggregateInput
  tech_categories: TechCategoryOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input ProjectRelationFilter {
  is: ProjectWhereInput
  isNot: ProjectWhereInput
}

enum ProjectScalarFieldEnum {
  admin_id
  app_url
  createdAt
  description
  github_url
  id
  image
  name
  updatedAt
}

input ProjectScalarWhereInput {
  AND: [ProjectScalarWhereInput!]
  NOT: [ProjectScalarWhereInput!]
  OR: [ProjectScalarWhereInput!]
  admin_id: StringFilter
  app_url: StringFilter
  createdAt: DateTimeFilter
  description: StringFilter
  github_url: StringFilter
  id: StringFilter
  image: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input ProjectScalarWhereWithAggregatesInput {
  AND: [ProjectScalarWhereWithAggregatesInput!]
  NOT: [ProjectScalarWhereWithAggregatesInput!]
  OR: [ProjectScalarWhereWithAggregatesInput!]
  admin_id: StringWithAggregatesFilter
  app_url: StringWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  description: StringWithAggregatesFilter
  github_url: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  image: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

input ProjectUpdateInput {
  admin: AdminUpdateOneRequiredWithoutProjectsInput
  app_url: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  github_url: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutProjectInput
  sketches: SketchUpdateManyWithoutProjectInput
  tech_categories: TechCategoryUpdateManyWithoutProjectInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyMutationInput {
  app_url: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  github_url: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateManyWithWhereWithoutAdminInput {
  data: ProjectUpdateManyMutationInput!
  where: ProjectScalarWhereInput!
}

input ProjectUpdateManyWithoutAdminInput {
  connect: [ProjectWhereUniqueInput!]
  connectOrCreate: [ProjectCreateOrConnectWithoutAdminInput!]
  create: [ProjectCreateWithoutAdminInput!]
  createMany: ProjectCreateManyAdminInputEnvelope
  delete: [ProjectWhereUniqueInput!]
  deleteMany: [ProjectScalarWhereInput!]
  disconnect: [ProjectWhereUniqueInput!]
  set: [ProjectWhereUniqueInput!]
  update: [ProjectUpdateWithWhereUniqueWithoutAdminInput!]
  updateMany: [ProjectUpdateManyWithWhereWithoutAdminInput!]
  upsert: [ProjectUpsertWithWhereUniqueWithoutAdminInput!]
}

input ProjectUpdateOneRequiredWithoutQuestionsInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutQuestionsInput
  create: ProjectCreateWithoutQuestionsInput
  update: ProjectUpdateWithoutQuestionsInput
  upsert: ProjectUpsertWithoutQuestionsInput
}

input ProjectUpdateOneRequiredWithoutSketchesInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutSketchesInput
  create: ProjectCreateWithoutSketchesInput
  update: ProjectUpdateWithoutSketchesInput
  upsert: ProjectUpsertWithoutSketchesInput
}

input ProjectUpdateOneRequiredWithoutTech_categoriesInput {
  connect: ProjectWhereUniqueInput
  connectOrCreate: ProjectCreateOrConnectWithoutTech_categoriesInput
  create: ProjectCreateWithoutTech_categoriesInput
  update: ProjectUpdateWithoutTech_categoriesInput
  upsert: ProjectUpsertWithoutTech_categoriesInput
}

input ProjectUpdateWithWhereUniqueWithoutAdminInput {
  data: ProjectUpdateWithoutAdminInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpdateWithoutAdminInput {
  app_url: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  github_url: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutProjectInput
  sketches: SketchUpdateManyWithoutProjectInput
  tech_categories: TechCategoryUpdateManyWithoutProjectInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutQuestionsInput {
  admin: AdminUpdateOneRequiredWithoutProjectsInput
  app_url: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  github_url: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  sketches: SketchUpdateManyWithoutProjectInput
  tech_categories: TechCategoryUpdateManyWithoutProjectInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutSketchesInput {
  admin: AdminUpdateOneRequiredWithoutProjectsInput
  app_url: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  github_url: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutProjectInput
  tech_categories: TechCategoryUpdateManyWithoutProjectInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpdateWithoutTech_categoriesInput {
  admin: AdminUpdateOneRequiredWithoutProjectsInput
  app_url: StringFieldUpdateOperationsInput
  createdAt: DateTimeFieldUpdateOperationsInput
  description: StringFieldUpdateOperationsInput
  github_url: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  questions: QuestionUpdateManyWithoutProjectInput
  sketches: SketchUpdateManyWithoutProjectInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ProjectUpsertWithWhereUniqueWithoutAdminInput {
  create: ProjectCreateWithoutAdminInput!
  update: ProjectUpdateWithoutAdminInput!
  where: ProjectWhereUniqueInput!
}

input ProjectUpsertWithoutQuestionsInput {
  create: ProjectCreateWithoutQuestionsInput!
  update: ProjectUpdateWithoutQuestionsInput!
}

input ProjectUpsertWithoutSketchesInput {
  create: ProjectCreateWithoutSketchesInput!
  update: ProjectUpdateWithoutSketchesInput!
}

input ProjectUpsertWithoutTech_categoriesInput {
  create: ProjectCreateWithoutTech_categoriesInput!
  update: ProjectUpdateWithoutTech_categoriesInput!
}

input ProjectWhereInput {
  AND: [ProjectWhereInput!]
  NOT: [ProjectWhereInput!]
  OR: [ProjectWhereInput!]
  admin: AdminRelationFilter
  admin_id: StringFilter
  app_url: StringFilter
  createdAt: DateTimeFilter
  description: StringFilter
  github_url: StringFilter
  id: StringFilter
  image: StringFilter
  name: StringFilter
  questions: QuestionListRelationFilter
  sketches: SketchListRelationFilter
  tech_categories: TechCategoryListRelationFilter
  updatedAt: DateTimeFilter
}

input ProjectWhereUniqueInput {
  id: String
}

type Query {
  about(where: AboutWhereUniqueInput!): About
  abouts(cursor: AboutWhereUniqueInput, distinct: [AboutScalarFieldEnum!], orderBy: [AboutOrderByWithRelationInput!], skip: Int, take: Int, where: AboutWhereInput): [About!]!
  admin(where: AdminWhereUniqueInput!): Admin
  admins(cursor: AdminWhereUniqueInput, distinct: [AdminScalarFieldEnum!], orderBy: [AdminOrderByWithRelationInput!], skip: Int, take: Int, where: AdminWhereInput): [Admin!]!
  aggregateAbout(cursor: AboutWhereUniqueInput, orderBy: [AboutOrderByWithRelationInput!], skip: Int, take: Int, where: AboutWhereInput): AggregateAbout!
  aggregateAdmin(cursor: AdminWhereUniqueInput, orderBy: [AdminOrderByWithRelationInput!], skip: Int, take: Int, where: AdminWhereInput): AggregateAdmin!
  aggregateAnswer(cursor: AnswerWhereUniqueInput, orderBy: [AnswerOrderByWithRelationInput!], skip: Int, take: Int, where: AnswerWhereInput): AggregateAnswer!
  aggregateMessage(cursor: MessageWhereUniqueInput, orderBy: [MessageOrderByWithRelationInput!], skip: Int, take: Int, where: MessageWhereInput): AggregateMessage!
  aggregateProject(cursor: ProjectWhereUniqueInput, orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): AggregateProject!
  aggregateQuestion(cursor: QuestionWhereUniqueInput, orderBy: [QuestionOrderByWithRelationInput!], skip: Int, take: Int, where: QuestionWhereInput): AggregateQuestion!
  aggregateSketch(cursor: SketchWhereUniqueInput, orderBy: [SketchOrderByWithRelationInput!], skip: Int, take: Int, where: SketchWhereInput): AggregateSketch!
  aggregateTech(cursor: TechWhereUniqueInput, orderBy: [TechOrderByWithRelationInput!], skip: Int, take: Int, where: TechWhereInput): AggregateTech!
  aggregateTechCategory(cursor: TechCategoryWhereUniqueInput, orderBy: [TechCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: TechCategoryWhereInput): AggregateTechCategory!
  answer(where: AnswerWhereUniqueInput!): Answer
  answers(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum!], orderBy: [AnswerOrderByWithRelationInput!], skip: Int, take: Int, where: AnswerWhereInput): [Answer!]!
  findFirstAbout(cursor: AboutWhereUniqueInput, distinct: [AboutScalarFieldEnum!], orderBy: [AboutOrderByWithRelationInput!], skip: Int, take: Int, where: AboutWhereInput): About
  findFirstAdmin(cursor: AdminWhereUniqueInput, distinct: [AdminScalarFieldEnum!], orderBy: [AdminOrderByWithRelationInput!], skip: Int, take: Int, where: AdminWhereInput): Admin
  findFirstAnswer(cursor: AnswerWhereUniqueInput, distinct: [AnswerScalarFieldEnum!], orderBy: [AnswerOrderByWithRelationInput!], skip: Int, take: Int, where: AnswerWhereInput): Answer
  findFirstMessage(cursor: MessageWhereUniqueInput, distinct: [MessageScalarFieldEnum!], orderBy: [MessageOrderByWithRelationInput!], skip: Int, take: Int, where: MessageWhereInput): Message
  findFirstProject(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): Project
  findFirstQuestion(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum!], orderBy: [QuestionOrderByWithRelationInput!], skip: Int, take: Int, where: QuestionWhereInput): Question
  findFirstSketch(cursor: SketchWhereUniqueInput, distinct: [SketchScalarFieldEnum!], orderBy: [SketchOrderByWithRelationInput!], skip: Int, take: Int, where: SketchWhereInput): Sketch
  findFirstTech(cursor: TechWhereUniqueInput, distinct: [TechScalarFieldEnum!], orderBy: [TechOrderByWithRelationInput!], skip: Int, take: Int, where: TechWhereInput): Tech
  findFirstTechCategory(cursor: TechCategoryWhereUniqueInput, distinct: [TechCategoryScalarFieldEnum!], orderBy: [TechCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: TechCategoryWhereInput): TechCategory
  groupByAbout(by: [AboutScalarFieldEnum!]!, having: AboutScalarWhereWithAggregatesInput, orderBy: [AboutOrderByWithAggregationInput!], skip: Int, take: Int, where: AboutWhereInput): [AboutGroupBy!]!
  groupByAdmin(by: [AdminScalarFieldEnum!]!, having: AdminScalarWhereWithAggregatesInput, orderBy: [AdminOrderByWithAggregationInput!], skip: Int, take: Int, where: AdminWhereInput): [AdminGroupBy!]!
  groupByAnswer(by: [AnswerScalarFieldEnum!]!, having: AnswerScalarWhereWithAggregatesInput, orderBy: [AnswerOrderByWithAggregationInput!], skip: Int, take: Int, where: AnswerWhereInput): [AnswerGroupBy!]!
  groupByMessage(by: [MessageScalarFieldEnum!]!, having: MessageScalarWhereWithAggregatesInput, orderBy: [MessageOrderByWithAggregationInput!], skip: Int, take: Int, where: MessageWhereInput): [MessageGroupBy!]!
  groupByProject(by: [ProjectScalarFieldEnum!]!, having: ProjectScalarWhereWithAggregatesInput, orderBy: [ProjectOrderByWithAggregationInput!], skip: Int, take: Int, where: ProjectWhereInput): [ProjectGroupBy!]!
  groupByQuestion(by: [QuestionScalarFieldEnum!]!, having: QuestionScalarWhereWithAggregatesInput, orderBy: [QuestionOrderByWithAggregationInput!], skip: Int, take: Int, where: QuestionWhereInput): [QuestionGroupBy!]!
  groupBySketch(by: [SketchScalarFieldEnum!]!, having: SketchScalarWhereWithAggregatesInput, orderBy: [SketchOrderByWithAggregationInput!], skip: Int, take: Int, where: SketchWhereInput): [SketchGroupBy!]!
  groupByTech(by: [TechScalarFieldEnum!]!, having: TechScalarWhereWithAggregatesInput, orderBy: [TechOrderByWithAggregationInput!], skip: Int, take: Int, where: TechWhereInput): [TechGroupBy!]!
  groupByTechCategory(by: [TechCategoryScalarFieldEnum!]!, having: TechCategoryScalarWhereWithAggregatesInput, orderBy: [TechCategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: TechCategoryWhereInput): [TechCategoryGroupBy!]!
  message(where: MessageWhereUniqueInput!): Message
  messages(cursor: MessageWhereUniqueInput, distinct: [MessageScalarFieldEnum!], orderBy: [MessageOrderByWithRelationInput!], skip: Int, take: Int, where: MessageWhereInput): [Message!]!
  project(where: ProjectWhereUniqueInput!): Project
  projects(cursor: ProjectWhereUniqueInput, distinct: [ProjectScalarFieldEnum!], orderBy: [ProjectOrderByWithRelationInput!], skip: Int, take: Int, where: ProjectWhereInput): [Project!]!
  question(where: QuestionWhereUniqueInput!): Question
  questions(cursor: QuestionWhereUniqueInput, distinct: [QuestionScalarFieldEnum!], orderBy: [QuestionOrderByWithRelationInput!], skip: Int, take: Int, where: QuestionWhereInput): [Question!]!
  sketch(where: SketchWhereUniqueInput!): Sketch
  sketches(cursor: SketchWhereUniqueInput, distinct: [SketchScalarFieldEnum!], orderBy: [SketchOrderByWithRelationInput!], skip: Int, take: Int, where: SketchWhereInput): [Sketch!]!
  tech(where: TechWhereUniqueInput!): Tech
  techCategories(cursor: TechCategoryWhereUniqueInput, distinct: [TechCategoryScalarFieldEnum!], orderBy: [TechCategoryOrderByWithRelationInput!], skip: Int, take: Int, where: TechCategoryWhereInput): [TechCategory!]!
  techCategory(where: TechCategoryWhereUniqueInput!): TechCategory
  teches(cursor: TechWhereUniqueInput, distinct: [TechScalarFieldEnum!], orderBy: [TechOrderByWithRelationInput!], skip: Int, take: Int, where: TechWhereInput): [Tech!]!
}

enum QueryMode {
  default
  insensitive
}

type Question {
  answer: Answer!
  answer_id: String!
  id: String!
  project: Project!
  project_id: String!
  question: String!
}

type QuestionCountAggregate {
  _all: Int!
  answer_id: Int!
  id: Int!
  project_id: Int!
  question: Int!
}

input QuestionCountOrderByAggregateInput {
  answer_id: SortOrder
  id: SortOrder
  project_id: SortOrder
  question: SortOrder
}

input QuestionCreateInput {
  answer: AnswerCreateNestedOneWithoutQuestionInput!
  id: String
  project: ProjectCreateNestedOneWithoutQuestionsInput!
  question: String!
}

input QuestionCreateManyInput {
  answer_id: String!
  id: String
  project_id: String!
  question: String!
}

input QuestionCreateManyProjectInput {
  answer_id: String!
  id: String
  question: String!
}

input QuestionCreateManyProjectInputEnvelope {
  data: [QuestionCreateManyProjectInput!]!
  skipDuplicates: Boolean
}

input QuestionCreateNestedManyWithoutProjectInput {
  connect: [QuestionWhereUniqueInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutProjectInput!]
  create: [QuestionCreateWithoutProjectInput!]
  createMany: QuestionCreateManyProjectInputEnvelope
}

input QuestionCreateNestedOneWithoutAnswerInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutAnswerInput
  create: QuestionCreateWithoutAnswerInput
}

input QuestionCreateOrConnectWithoutAnswerInput {
  create: QuestionCreateWithoutAnswerInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateOrConnectWithoutProjectInput {
  create: QuestionCreateWithoutProjectInput!
  where: QuestionWhereUniqueInput!
}

input QuestionCreateWithoutAnswerInput {
  id: String
  project: ProjectCreateNestedOneWithoutQuestionsInput!
  question: String!
}

input QuestionCreateWithoutProjectInput {
  answer: AnswerCreateNestedOneWithoutQuestionInput!
  id: String
  question: String!
}

type QuestionGroupBy {
  _count: QuestionCountAggregate
  _max: QuestionMaxAggregate
  _min: QuestionMinAggregate
  answer_id: String!
  id: String!
  project_id: String!
  question: String!
}

input QuestionListRelationFilter {
  every: QuestionWhereInput
  none: QuestionWhereInput
  some: QuestionWhereInput
}

type QuestionMaxAggregate {
  answer_id: String
  id: String
  project_id: String
  question: String
}

input QuestionMaxOrderByAggregateInput {
  answer_id: SortOrder
  id: SortOrder
  project_id: SortOrder
  question: SortOrder
}

type QuestionMinAggregate {
  answer_id: String
  id: String
  project_id: String
  question: String
}

input QuestionMinOrderByAggregateInput {
  answer_id: SortOrder
  id: SortOrder
  project_id: SortOrder
  question: SortOrder
}

input QuestionOrderByRelationAggregateInput {
  _count: SortOrder
}

input QuestionOrderByWithAggregationInput {
  _count: QuestionCountOrderByAggregateInput
  _max: QuestionMaxOrderByAggregateInput
  _min: QuestionMinOrderByAggregateInput
  answer_id: SortOrder
  id: SortOrder
  project_id: SortOrder
  question: SortOrder
}

input QuestionOrderByWithRelationInput {
  answer: AnswerOrderByWithRelationInput
  answer_id: SortOrder
  id: SortOrder
  project: ProjectOrderByWithRelationInput
  project_id: SortOrder
  question: SortOrder
}

input QuestionRelationFilter {
  is: QuestionWhereInput
  isNot: QuestionWhereInput
}

enum QuestionScalarFieldEnum {
  answer_id
  id
  project_id
  question
}

input QuestionScalarWhereInput {
  AND: [QuestionScalarWhereInput!]
  NOT: [QuestionScalarWhereInput!]
  OR: [QuestionScalarWhereInput!]
  answer_id: StringFilter
  id: StringFilter
  project_id: StringFilter
  question: StringFilter
}

input QuestionScalarWhereWithAggregatesInput {
  AND: [QuestionScalarWhereWithAggregatesInput!]
  NOT: [QuestionScalarWhereWithAggregatesInput!]
  OR: [QuestionScalarWhereWithAggregatesInput!]
  answer_id: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  project_id: StringWithAggregatesFilter
  question: StringWithAggregatesFilter
}

input QuestionUpdateInput {
  answer: AnswerUpdateOneRequiredWithoutQuestionInput
  id: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutQuestionsInput
  question: StringFieldUpdateOperationsInput
}

input QuestionUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  question: StringFieldUpdateOperationsInput
}

input QuestionUpdateManyWithWhereWithoutProjectInput {
  data: QuestionUpdateManyMutationInput!
  where: QuestionScalarWhereInput!
}

input QuestionUpdateManyWithoutProjectInput {
  connect: [QuestionWhereUniqueInput!]
  connectOrCreate: [QuestionCreateOrConnectWithoutProjectInput!]
  create: [QuestionCreateWithoutProjectInput!]
  createMany: QuestionCreateManyProjectInputEnvelope
  delete: [QuestionWhereUniqueInput!]
  deleteMany: [QuestionScalarWhereInput!]
  disconnect: [QuestionWhereUniqueInput!]
  set: [QuestionWhereUniqueInput!]
  update: [QuestionUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [QuestionUpdateManyWithWhereWithoutProjectInput!]
  upsert: [QuestionUpsertWithWhereUniqueWithoutProjectInput!]
}

input QuestionUpdateOneWithoutAnswerInput {
  connect: QuestionWhereUniqueInput
  connectOrCreate: QuestionCreateOrConnectWithoutAnswerInput
  create: QuestionCreateWithoutAnswerInput
  delete: Boolean
  disconnect: Boolean
  update: QuestionUpdateWithoutAnswerInput
  upsert: QuestionUpsertWithoutAnswerInput
}

input QuestionUpdateWithWhereUniqueWithoutProjectInput {
  data: QuestionUpdateWithoutProjectInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpdateWithoutAnswerInput {
  id: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutQuestionsInput
  question: StringFieldUpdateOperationsInput
}

input QuestionUpdateWithoutProjectInput {
  answer: AnswerUpdateOneRequiredWithoutQuestionInput
  id: StringFieldUpdateOperationsInput
  question: StringFieldUpdateOperationsInput
}

input QuestionUpsertWithWhereUniqueWithoutProjectInput {
  create: QuestionCreateWithoutProjectInput!
  update: QuestionUpdateWithoutProjectInput!
  where: QuestionWhereUniqueInput!
}

input QuestionUpsertWithoutAnswerInput {
  create: QuestionCreateWithoutAnswerInput!
  update: QuestionUpdateWithoutAnswerInput!
}

input QuestionWhereInput {
  AND: [QuestionWhereInput!]
  NOT: [QuestionWhereInput!]
  OR: [QuestionWhereInput!]
  answer: AnswerRelationFilter
  answer_id: StringFilter
  id: StringFilter
  project: ProjectRelationFilter
  project_id: StringFilter
  question: StringFilter
}

input QuestionWhereUniqueInput {
  id: String
}

type Sketch {
  body: String!
  download_link: String!
  id: String!
  image: String!
  project: Project!
  project_id: String!
  title: String!
}

type SketchCountAggregate {
  _all: Int!
  body: Int!
  download_link: Int!
  id: Int!
  image: Int!
  project_id: Int!
  title: Int!
}

input SketchCountOrderByAggregateInput {
  body: SortOrder
  download_link: SortOrder
  id: SortOrder
  image: SortOrder
  project_id: SortOrder
  title: SortOrder
}

input SketchCreateInput {
  body: String!
  download_link: String!
  id: String
  image: String!
  project: ProjectCreateNestedOneWithoutSketchesInput!
  title: String!
}

input SketchCreateManyInput {
  body: String!
  download_link: String!
  id: String
  image: String!
  project_id: String!
  title: String!
}

input SketchCreateManyProjectInput {
  body: String!
  download_link: String!
  id: String
  image: String!
  title: String!
}

input SketchCreateManyProjectInputEnvelope {
  data: [SketchCreateManyProjectInput!]!
  skipDuplicates: Boolean
}

input SketchCreateNestedManyWithoutProjectInput {
  connect: [SketchWhereUniqueInput!]
  connectOrCreate: [SketchCreateOrConnectWithoutProjectInput!]
  create: [SketchCreateWithoutProjectInput!]
  createMany: SketchCreateManyProjectInputEnvelope
}

input SketchCreateOrConnectWithoutProjectInput {
  create: SketchCreateWithoutProjectInput!
  where: SketchWhereUniqueInput!
}

input SketchCreateWithoutProjectInput {
  body: String!
  download_link: String!
  id: String
  image: String!
  title: String!
}

type SketchGroupBy {
  _count: SketchCountAggregate
  _max: SketchMaxAggregate
  _min: SketchMinAggregate
  body: String!
  download_link: String!
  id: String!
  image: String!
  project_id: String!
  title: String!
}

input SketchListRelationFilter {
  every: SketchWhereInput
  none: SketchWhereInput
  some: SketchWhereInput
}

type SketchMaxAggregate {
  body: String
  download_link: String
  id: String
  image: String
  project_id: String
  title: String
}

input SketchMaxOrderByAggregateInput {
  body: SortOrder
  download_link: SortOrder
  id: SortOrder
  image: SortOrder
  project_id: SortOrder
  title: SortOrder
}

type SketchMinAggregate {
  body: String
  download_link: String
  id: String
  image: String
  project_id: String
  title: String
}

input SketchMinOrderByAggregateInput {
  body: SortOrder
  download_link: SortOrder
  id: SortOrder
  image: SortOrder
  project_id: SortOrder
  title: SortOrder
}

input SketchOrderByRelationAggregateInput {
  _count: SortOrder
}

input SketchOrderByWithAggregationInput {
  _count: SketchCountOrderByAggregateInput
  _max: SketchMaxOrderByAggregateInput
  _min: SketchMinOrderByAggregateInput
  body: SortOrder
  download_link: SortOrder
  id: SortOrder
  image: SortOrder
  project_id: SortOrder
  title: SortOrder
}

input SketchOrderByWithRelationInput {
  body: SortOrder
  download_link: SortOrder
  id: SortOrder
  image: SortOrder
  project: ProjectOrderByWithRelationInput
  project_id: SortOrder
  title: SortOrder
}

enum SketchScalarFieldEnum {
  body
  download_link
  id
  image
  project_id
  title
}

input SketchScalarWhereInput {
  AND: [SketchScalarWhereInput!]
  NOT: [SketchScalarWhereInput!]
  OR: [SketchScalarWhereInput!]
  body: StringFilter
  download_link: StringFilter
  id: StringFilter
  image: StringFilter
  project_id: StringFilter
  title: StringFilter
}

input SketchScalarWhereWithAggregatesInput {
  AND: [SketchScalarWhereWithAggregatesInput!]
  NOT: [SketchScalarWhereWithAggregatesInput!]
  OR: [SketchScalarWhereWithAggregatesInput!]
  body: StringWithAggregatesFilter
  download_link: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  image: StringWithAggregatesFilter
  project_id: StringWithAggregatesFilter
  title: StringWithAggregatesFilter
}

input SketchUpdateInput {
  body: StringFieldUpdateOperationsInput
  download_link: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutSketchesInput
  title: StringFieldUpdateOperationsInput
}

input SketchUpdateManyMutationInput {
  body: StringFieldUpdateOperationsInput
  download_link: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input SketchUpdateManyWithWhereWithoutProjectInput {
  data: SketchUpdateManyMutationInput!
  where: SketchScalarWhereInput!
}

input SketchUpdateManyWithoutProjectInput {
  connect: [SketchWhereUniqueInput!]
  connectOrCreate: [SketchCreateOrConnectWithoutProjectInput!]
  create: [SketchCreateWithoutProjectInput!]
  createMany: SketchCreateManyProjectInputEnvelope
  delete: [SketchWhereUniqueInput!]
  deleteMany: [SketchScalarWhereInput!]
  disconnect: [SketchWhereUniqueInput!]
  set: [SketchWhereUniqueInput!]
  update: [SketchUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [SketchUpdateManyWithWhereWithoutProjectInput!]
  upsert: [SketchUpsertWithWhereUniqueWithoutProjectInput!]
}

input SketchUpdateWithWhereUniqueWithoutProjectInput {
  data: SketchUpdateWithoutProjectInput!
  where: SketchWhereUniqueInput!
}

input SketchUpdateWithoutProjectInput {
  body: StringFieldUpdateOperationsInput
  download_link: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  title: StringFieldUpdateOperationsInput
}

input SketchUpsertWithWhereUniqueWithoutProjectInput {
  create: SketchCreateWithoutProjectInput!
  update: SketchUpdateWithoutProjectInput!
  where: SketchWhereUniqueInput!
}

input SketchWhereInput {
  AND: [SketchWhereInput!]
  NOT: [SketchWhereInput!]
  OR: [SketchWhereInput!]
  body: StringFilter
  download_link: StringFilter
  id: StringFilter
  image: StringFilter
  project: ProjectRelationFilter
  project_id: StringFilter
  title: StringFilter
}

input SketchWhereUniqueInput {
  id: String
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type Tech {
  id: String!
  name: String!
  tech_categories: TechCategory!
  tech_category_id: String!
}

type TechCategory {
  _count: TechCategoryCount
  id: String!
  name: String!
  project: Project!
  project_id: String!
  techs(cursor: TechWhereUniqueInput, distinct: [TechScalarFieldEnum!], orderBy: [TechOrderByWithRelationInput!], skip: Int, take: Int, where: TechWhereInput): [Tech!]!
}

type TechCategoryCount {
  techs: Int!
}

type TechCategoryCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  project_id: Int!
}

input TechCategoryCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  project_id: SortOrder
}

input TechCategoryCreateInput {
  id: String
  name: String!
  project: ProjectCreateNestedOneWithoutTech_categoriesInput!
  techs: TechCreateNestedManyWithoutTech_categoriesInput
}

input TechCategoryCreateManyInput {
  id: String
  name: String!
  project_id: String!
}

input TechCategoryCreateManyProjectInput {
  id: String
  name: String!
}

input TechCategoryCreateManyProjectInputEnvelope {
  data: [TechCategoryCreateManyProjectInput!]!
  skipDuplicates: Boolean
}

input TechCategoryCreateNestedManyWithoutProjectInput {
  connect: [TechCategoryWhereUniqueInput!]
  connectOrCreate: [TechCategoryCreateOrConnectWithoutProjectInput!]
  create: [TechCategoryCreateWithoutProjectInput!]
  createMany: TechCategoryCreateManyProjectInputEnvelope
}

input TechCategoryCreateNestedOneWithoutTechsInput {
  connect: TechCategoryWhereUniqueInput
  connectOrCreate: TechCategoryCreateOrConnectWithoutTechsInput
  create: TechCategoryCreateWithoutTechsInput
}

input TechCategoryCreateOrConnectWithoutProjectInput {
  create: TechCategoryCreateWithoutProjectInput!
  where: TechCategoryWhereUniqueInput!
}

input TechCategoryCreateOrConnectWithoutTechsInput {
  create: TechCategoryCreateWithoutTechsInput!
  where: TechCategoryWhereUniqueInput!
}

input TechCategoryCreateWithoutProjectInput {
  id: String
  name: String!
  techs: TechCreateNestedManyWithoutTech_categoriesInput
}

input TechCategoryCreateWithoutTechsInput {
  id: String
  name: String!
  project: ProjectCreateNestedOneWithoutTech_categoriesInput!
}

type TechCategoryGroupBy {
  _count: TechCategoryCountAggregate
  _max: TechCategoryMaxAggregate
  _min: TechCategoryMinAggregate
  id: String!
  name: String!
  project_id: String!
}

input TechCategoryListRelationFilter {
  every: TechCategoryWhereInput
  none: TechCategoryWhereInput
  some: TechCategoryWhereInput
}

type TechCategoryMaxAggregate {
  id: String
  name: String
  project_id: String
}

input TechCategoryMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  project_id: SortOrder
}

type TechCategoryMinAggregate {
  id: String
  name: String
  project_id: String
}

input TechCategoryMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  project_id: SortOrder
}

input TechCategoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input TechCategoryOrderByWithAggregationInput {
  _count: TechCategoryCountOrderByAggregateInput
  _max: TechCategoryMaxOrderByAggregateInput
  _min: TechCategoryMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  project_id: SortOrder
}

input TechCategoryOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  project: ProjectOrderByWithRelationInput
  project_id: SortOrder
  techs: TechOrderByRelationAggregateInput
}

input TechCategoryRelationFilter {
  is: TechCategoryWhereInput
  isNot: TechCategoryWhereInput
}

enum TechCategoryScalarFieldEnum {
  id
  name
  project_id
}

input TechCategoryScalarWhereInput {
  AND: [TechCategoryScalarWhereInput!]
  NOT: [TechCategoryScalarWhereInput!]
  OR: [TechCategoryScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  project_id: StringFilter
}

input TechCategoryScalarWhereWithAggregatesInput {
  AND: [TechCategoryScalarWhereWithAggregatesInput!]
  NOT: [TechCategoryScalarWhereWithAggregatesInput!]
  OR: [TechCategoryScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  project_id: StringWithAggregatesFilter
}

input TechCategoryUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTech_categoriesInput
  techs: TechUpdateManyWithoutTech_categoriesInput
}

input TechCategoryUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TechCategoryUpdateManyWithWhereWithoutProjectInput {
  data: TechCategoryUpdateManyMutationInput!
  where: TechCategoryScalarWhereInput!
}

input TechCategoryUpdateManyWithoutProjectInput {
  connect: [TechCategoryWhereUniqueInput!]
  connectOrCreate: [TechCategoryCreateOrConnectWithoutProjectInput!]
  create: [TechCategoryCreateWithoutProjectInput!]
  createMany: TechCategoryCreateManyProjectInputEnvelope
  delete: [TechCategoryWhereUniqueInput!]
  deleteMany: [TechCategoryScalarWhereInput!]
  disconnect: [TechCategoryWhereUniqueInput!]
  set: [TechCategoryWhereUniqueInput!]
  update: [TechCategoryUpdateWithWhereUniqueWithoutProjectInput!]
  updateMany: [TechCategoryUpdateManyWithWhereWithoutProjectInput!]
  upsert: [TechCategoryUpsertWithWhereUniqueWithoutProjectInput!]
}

input TechCategoryUpdateOneRequiredWithoutTechsInput {
  connect: TechCategoryWhereUniqueInput
  connectOrCreate: TechCategoryCreateOrConnectWithoutTechsInput
  create: TechCategoryCreateWithoutTechsInput
  update: TechCategoryUpdateWithoutTechsInput
  upsert: TechCategoryUpsertWithoutTechsInput
}

input TechCategoryUpdateWithWhereUniqueWithoutProjectInput {
  data: TechCategoryUpdateWithoutProjectInput!
  where: TechCategoryWhereUniqueInput!
}

input TechCategoryUpdateWithoutProjectInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  techs: TechUpdateManyWithoutTech_categoriesInput
}

input TechCategoryUpdateWithoutTechsInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  project: ProjectUpdateOneRequiredWithoutTech_categoriesInput
}

input TechCategoryUpsertWithWhereUniqueWithoutProjectInput {
  create: TechCategoryCreateWithoutProjectInput!
  update: TechCategoryUpdateWithoutProjectInput!
  where: TechCategoryWhereUniqueInput!
}

input TechCategoryUpsertWithoutTechsInput {
  create: TechCategoryCreateWithoutTechsInput!
  update: TechCategoryUpdateWithoutTechsInput!
}

input TechCategoryWhereInput {
  AND: [TechCategoryWhereInput!]
  NOT: [TechCategoryWhereInput!]
  OR: [TechCategoryWhereInput!]
  id: StringFilter
  name: StringFilter
  project: ProjectRelationFilter
  project_id: StringFilter
  techs: TechListRelationFilter
}

input TechCategoryWhereUniqueInput {
  id: String
}

type TechCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  tech_category_id: Int!
}

input TechCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  tech_category_id: SortOrder
}

input TechCreateInput {
  id: String
  name: String!
  tech_categories: TechCategoryCreateNestedOneWithoutTechsInput!
}

input TechCreateManyInput {
  id: String
  name: String!
  tech_category_id: String!
}

input TechCreateManyTech_categoriesInput {
  id: String
  name: String!
}

input TechCreateManyTech_categoriesInputEnvelope {
  data: [TechCreateManyTech_categoriesInput!]!
  skipDuplicates: Boolean
}

input TechCreateNestedManyWithoutTech_categoriesInput {
  connect: [TechWhereUniqueInput!]
  connectOrCreate: [TechCreateOrConnectWithoutTech_categoriesInput!]
  create: [TechCreateWithoutTech_categoriesInput!]
  createMany: TechCreateManyTech_categoriesInputEnvelope
}

input TechCreateOrConnectWithoutTech_categoriesInput {
  create: TechCreateWithoutTech_categoriesInput!
  where: TechWhereUniqueInput!
}

input TechCreateWithoutTech_categoriesInput {
  id: String
  name: String!
}

type TechGroupBy {
  _count: TechCountAggregate
  _max: TechMaxAggregate
  _min: TechMinAggregate
  id: String!
  name: String!
  tech_category_id: String!
}

input TechListRelationFilter {
  every: TechWhereInput
  none: TechWhereInput
  some: TechWhereInput
}

type TechMaxAggregate {
  id: String
  name: String
  tech_category_id: String
}

input TechMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  tech_category_id: SortOrder
}

type TechMinAggregate {
  id: String
  name: String
  tech_category_id: String
}

input TechMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  tech_category_id: SortOrder
}

input TechOrderByRelationAggregateInput {
  _count: SortOrder
}

input TechOrderByWithAggregationInput {
  _count: TechCountOrderByAggregateInput
  _max: TechMaxOrderByAggregateInput
  _min: TechMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  tech_category_id: SortOrder
}

input TechOrderByWithRelationInput {
  id: SortOrder
  name: SortOrder
  tech_categories: TechCategoryOrderByWithRelationInput
  tech_category_id: SortOrder
}

enum TechScalarFieldEnum {
  id
  name
  tech_category_id
}

input TechScalarWhereInput {
  AND: [TechScalarWhereInput!]
  NOT: [TechScalarWhereInput!]
  OR: [TechScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  tech_category_id: StringFilter
}

input TechScalarWhereWithAggregatesInput {
  AND: [TechScalarWhereWithAggregatesInput!]
  NOT: [TechScalarWhereWithAggregatesInput!]
  OR: [TechScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  tech_category_id: StringWithAggregatesFilter
}

input TechUpdateInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  tech_categories: TechCategoryUpdateOneRequiredWithoutTechsInput
}

input TechUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TechUpdateManyWithWhereWithoutTech_categoriesInput {
  data: TechUpdateManyMutationInput!
  where: TechScalarWhereInput!
}

input TechUpdateManyWithoutTech_categoriesInput {
  connect: [TechWhereUniqueInput!]
  connectOrCreate: [TechCreateOrConnectWithoutTech_categoriesInput!]
  create: [TechCreateWithoutTech_categoriesInput!]
  createMany: TechCreateManyTech_categoriesInputEnvelope
  delete: [TechWhereUniqueInput!]
  deleteMany: [TechScalarWhereInput!]
  disconnect: [TechWhereUniqueInput!]
  set: [TechWhereUniqueInput!]
  update: [TechUpdateWithWhereUniqueWithoutTech_categoriesInput!]
  updateMany: [TechUpdateManyWithWhereWithoutTech_categoriesInput!]
  upsert: [TechUpsertWithWhereUniqueWithoutTech_categoriesInput!]
}

input TechUpdateWithWhereUniqueWithoutTech_categoriesInput {
  data: TechUpdateWithoutTech_categoriesInput!
  where: TechWhereUniqueInput!
}

input TechUpdateWithoutTech_categoriesInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input TechUpsertWithWhereUniqueWithoutTech_categoriesInput {
  create: TechCreateWithoutTech_categoriesInput!
  update: TechUpdateWithoutTech_categoriesInput!
  where: TechWhereUniqueInput!
}

input TechWhereInput {
  AND: [TechWhereInput!]
  NOT: [TechWhereInput!]
  OR: [TechWhereInput!]
  id: StringFilter
  name: StringFilter
  tech_categories: TechCategoryRelationFilter
  tech_category_id: StringFilter
}

input TechWhereUniqueInput {
  id: String
}
